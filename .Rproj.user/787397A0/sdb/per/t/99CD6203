{
    "collab_server" : "",
    "contents" : "#' Plot strophes and identify syllables and pulses\n#' \n#' Plot pre-identified strophes  at the three levels in one plot, the \n#' difference between the coarsest and intermediate level in a second plot (for \n#' syllable identification) and the differeence between finest and intermidiate \n#' level in a third plot (in a third plot). Also applies automated syllable and \n#' strophe identification.\n#'\n#' @param envFine A sound envelope as a vector of numbers.\n#' @param wavfile Name of wavfile (necessary).\n#' @param syllpath Path to folder in wich jpg files should be plotted (optional, \n#'   working directory if missing).\n#' @param identify Boolean. Whether or not syllable and puls boundaries should \n#'   be identified automatically.\n#' @param plot Boolean. Whether or not the data should be plotted.\n#' @param f Sampling rate (extracted from wavfile if NULL).\n#' @param toFile Boolean, whether or not the plot should be in a .jpg file (if \n#'   TRUE) or in a plotting window (if FALSE).\n#' @param bmpwidth Width of the jpg image (in pixels).\n#' @param bmpheight Height of the jpg image (in pixels).\n#' @param rollmeanWW Vector of 2 (preferentially odd) numbers. The rolling mean \n#'   window width for determining the coarse and intermediate envolopes from \n#'   the finest resultion envolope determined by \\code{wl} and \\code{ovlp}. The \n#'   code works more accurate for odd numbers!\n#' @param rollmeanWWdiff Vector of 2 (preferentially odd) numbers. The rolling \n#'   mean window width for smoothing the difference between intermediate and \n#'   coarse envolope (first value, for syllable identification) and fine and \n#'   intermediate level (second value, for pulse indentification). The code \n#'   works more accurate for odd numbers!\n#' @param meanReduceFrac Vector of 2 numbers (range 0-1) giving the fractional \n#'   reduce of the average threshold towards the mean for syllable (first \n#'   number) and puls (second number) identification.\n#' @param tol Tolerance for the detection of minima (handed over to \n#'   \\code{\\link{peakIdent}}). Should be some low value or 0.\n#' @param wl Window length used when determining the sound envelope (used here \n#'   only for back-conversion to time in seconds).\n#' @param ovlp Overlap used when determining the sound envelope (used here only\n#'   for back-conversion to time in seconds).\n#' @param stroAmpThresh Envelope threshold for identification of silence/sound \n#'   (used here only for plotting).\n#' @param stroCutoffs A \\code{data.frame} containing the strophe cutoff \n#'   locations as returned by \\code{\\link{identifyStrophes}}.\n#' @param minSyllDur Min syllable duration in seconds.\n#' @param maxSyllDur Max syllable duration in seconds.\n#' @param syllCutoffs A \\code{data.frame} containing the syllable cutoff \n#'   locations as returned by \\code{\\link{identifyStrophes}} (useful if they \n#'   have been manually curated).\n#' @param xlimFullPlot A vector of two numbers that determine the x limits \n#'   (given in units of samples) to the full plot (for zooming in). If NULL the\n#'   full range is plotted.\n#' @param xlimSyllPlot A vector of two numbers that determine the x limits \n#'   (given in units of samples) to the syllable plot (for zooming in). If NULL \n#'   the full range is plotted.\n#' @param xlimSumPlot A vector of two numbers that determine the x limits \n#'   (given in units of samples) to the summary plot (for zooming in). If NULL \n#'   the full range is plotted.\n#' @param mCleanIt Number of interations for the second cleaning filter \n#'   (removing minima, where the rolling mean has not exceeded the average \n#'   amplituted difference).\n#' @param mar A vector of four numbers giving the margins of the plot.\n#' @param cex Size of the syllable counter on the plot.\n#' @param lwdSyllSep Line width of the syllable seperator lines.\n#' @param writeRes Boolean. Whether or not the strophe cutoffs should be \n#'   written to file.\n#' @param overwriteRes Boolean. This is just a safty catch. If  \\code{write = TRUE}\n#'   and \\code{overwriteRes = FALSE} the function will stop in order not to \n#'   overwrite previous manual edits.\n#' @param useResFile Boolean. A check is done, if a results file already exists and\n#'   the results of this file are used in \\code{useResFile = TRUE}\n#' \n#' @return \n#' Returns the a list.\n#' \\item{syllCutoffs}{A \\code{data.frame} of detected syllable cutoff points. The elements are:\n#'   \\describe{\n#'      \\item{StartSampWithPad}{The strophe start as the sample in \\code{envFine} in the padded sequence.}\n#'      \\item{EndSampWithPad}{The strophe end as the sample in \\code{envFine} in the padded sequence.}\n#'      \\item{StartSampWoutPad}{The strophe start as the sample in \\code{envFine} in sequence without padding.}\n#'      \\item{EndSampWoutPad}{The strophe end as the sample in \\code{envFine} in sequence without padding.}\n#'      \\item{StartSec}{The strophe start converted to seconds of the song without padding.}\n#'      \\item{EndSec}{The strophe end converted to seconds of the song without padding.}\n#'      \\item{DurSec}{The strophe duration in seconds.}\n#'      \\item{StroCounter}{A counter for strophes within the \\code{song}.}\n#'    }\n#'  }\n#' \\item{pulsSummary}{A \\code{data.frame} of detected puls cutoff points. The elements are:\n#'   \\describe{\n#'      \\item{StartSampWithPad}{The strophe start as the sample in \\code{envFine} in the padded sequence.}\n#'      \\item{EndSampWithPad}{The strophe end as the sample in \\code{envFine} in the padded sequence.}\n#'      \\item{StartSampWoutPad}{The strophe start as the sample in \\code{envFine} in sequence without padding.}\n#'      \\item{EndSampWoutPad}{The strophe end as the sample in \\code{envFine} in sequence without padding.}\n#'      \\item{StartSec}{The strophe start converted to seconds of the song without padding.}\n#'      \\item{EndSec}{The strophe end converted to seconds of the song without padding.}\n#'      \\item{DurSec}{The strophe duration in seconds.}\n#'      \\item{StroCounter}{A counter for strophes within the \\code{song}.}\n#'    }\n#'  }\n#'  \n#' @references \n#' My references\n#' \n#' @author Holger Schielzeth  (holger.schielzeth@@uni-bielefeld.de)\n#' \n#' @seealso \n#' \\code{\\link{loadSongfile}}, \\code{\\link{curateStrophes}}, \n#' \\code{\\link{identifyStrophes}}, \\code{\\link{measureSyllables}}, \n#' \\code{\\link{identifyPulses}}, \\code{\\link{curateSyllables}}.\n#' \n#' @examples   \n#' \n#' \\dontrun{\n#' \n#' mysound = filePreparation(\"myfile.wav\", \"C://mypath//\", highpassfilter=1001, select=c(0.5,2))\n#' myenv = plotEnvolopes(mysound, \"myfile.wav\", \"c://mystropath//\", padding = 300)\n#' mystro = plotStrophes(myenv$envFine, \"myfile.wav\", \"C://mypath//\")\n#' }\n#' \n#' \n#' @export\n\nidentifySyllables <- function(envFine, wavfile, syllpath=\"\", identify=TRUE, plot=TRUE, f=44100, \n                              toFile=TRUE, bmpwidth=3200, bmpheight=1200,\n                              rollmeanWW=c(11, 101), rollmeanWWdiff=c(51, 1), \n                              tol=1e-7, wl=44, ovlp=50, meanReduceFrac=c(0.4,0.1), mCleanIt=3,\n                              minSyllDur=0, maxSyllDur=1,\n                              stroAmpThresh=15, stroCutoffs=NULL, syllCutoffs=NULL, \n                              xlimFullPlot=NULL, xlimSyllPlot=NULL, xlimSumPlot=NULL, mar=NULL, cex=2, lwdSyllSep=2,\n                              writeRes=TRUE, overwriteRes=FALSE, useResFile=TRUE) {\n  \n  if(any(rollmeanWW %% 2 == 0)) warning(\"Roll means window width should be odd numbers for higher accuracy. Found for rollmeanWW.\")\n  if(any(rollmeanWWdiff %% 2 == 0)) warning(\"Roll means window width should be odd numbers for higher accuracy. Found for rollmeanWWdiff.\")\n  if(syllpath!=\"\") {\n    if (!dir.exists(syllpath)) {\n      dir.create(syllpath)\n      print(paste0(\"Directory \", syllpath, \" did not exist and was created.\"))\n    }\n  }\n  if(identify==FALSE) meanReduceSyll = 0\n  stroCutoffs = stroCutoffs[stroCutoffs$StroValid == 1,]\n  if(nrow(stroCutoffs)>=1) {\n    for(i in 1:nrow(stroCutoffs)) {\n      readfile = paste0(syllpath,unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\"_Strophe\", stroCutoffs$StroCounter[i], \"_Syllables.txt\")\n      if(useResFile && file.exists(readfile)) {\n        syllCutoffs = read.table(file=readfile, sep=\"\\t\", header=TRUE)\n        identify = FALSE\n        print(\"Syllable identification: Existing file was read and used for cutoffs! identify was set to FALSE!\")\n      }\n      \n      if(identify || plot) {\n        # calculate rollmeans envMedi and envCoar\n        envCoar = zoo::rollmean(envFine, rollmeanWW[1], align=\"center\")\n        envCoar = c(rep(envCoar[1], (rollmeanWW[1]-1)/2), envCoar, rep(envCoar[length(envCoar)], (rollmeanWW[1]-1)/2))\n        #$    envMedi = zoo::rollmean(envFine, rollmeanWW[2], align=\"center\")\n        #$    envMedi = c(rep(envMedi[1], (rollmeanWW[2]-1)/2), envMedi, rep(envMedi[length(envMedi)], (rollmeanWW[2]-1)/2))\n  \n        # truncation of evelopes to strophe window\n        truncEnvStroph = function(x, start, end, samp=1) x = x[I(start*samp):I(end*samp)]\n        start   = stroCutoffs$StartSampWoutPad[i]\n          if(start<0) start = 0\n        end     = stroCutoffs$EndSampWoutPad[i]\n        #samp    = f / (wl[1]*(1-ovlp[1]/100))\n        envFineTrunc = truncEnvStroph(envFine, start, end)\n        #$    envMediTrunc = truncEnvStroph(envMedi, start, end)\n        envCoarTrunc = truncEnvStroph(envCoar, start, end)\n        mytime = length(envFineTrunc)/(f/(wl*(1-ovlp/100))) #$\n\n        # Calculation of standardized differences\n        standFactor = function(x) {max(x)/x}\n        diffSyll = envFineTrunc * standFactor(envCoarTrunc)  # IMPORTANT CHANGE HERE! envMediTrunc to envFineTrunc\n    \n        # Syllable and puls rollmeans\n        rollmeansSyll    = zoo::rollmean(diffSyll,  rollmeanWWdiff[1], align=\"center\")\n        rollmeansSyll    = c(rep(rollmeansSyll[1], (rollmeanWWdiff[1]-1)/2), rollmeansSyll, rep(rollmeansSyll[length(rollmeansSyll)], (rollmeanWWdiff[1]-1)/2))\n      }\n      \n      # Syllable identification\n      if(identify==TRUE) {\n        meanReduceSyll   = (mean(rollmeansSyll)-min(rollmeansSyll))*meanReduceFrac[1]\n        rollmeanSignSyll = as.numeric(rollmeansSyll<=mean(rollmeansSyll)-meanReduceSyll)\n        syllCutoffs      = peakIdent(rollmeansSyll, tol=tol, decreasing=TRUE)\n        # Cleaning Filter 1\n        syllCutoffsValid = as.numeric(rollmeanSignSyll[syllCutoffs]==1)\n        syllCutoffs      = syllCutoffs[syllCutoffsValid==1]\n        # Cleaning Filter 2\n        for(k in 1:mCleanIt) { # Hidden switch\n          syllCutoffsValid = rep(1,length(syllCutoffs))\n          rollmeanSignSyllAvg = as.numeric(rollmeansSyll>mean(rollmeansSyll))\n          for(j in 2:length(syllCutoffs)) {\n            if(sum(rollmeanSignSyllAvg[syllCutoffs[j-1]:syllCutoffs[j]]) == 0) {\n             if(envFine[syllCutoffs[j-1]] < envFine[syllCutoffs[j]]) syllCutoffsValid[j]   = 0\n             if(envFine[syllCutoffs[j-1]] > envFine[syllCutoffs[j]]) syllCutoffsValid[j-1] = 0\n            }\n          }  \n          syllCutoffs      = syllCutoffs[syllCutoffsValid==1]\n        }    \n        if(rollmeanWWdiff[1]>1) {\n          for(j in 1:length(syllCutoffs)) {\n            rollmeanWind = syllCutoffs[j] + c(-1,1) * (rollmeanWWdiff[1]-1)/2\n            diffSyllwindow = envFine[rollmeanWind[1]:rollmeanWind[2]]                  # IMPORTANT CHANGE HERE diffSyll to envFine\n            shift = which(diffSyllwindow == min(diffSyllwindow, na.rm=TRUE)) - 1 - (rollmeanWWdiff[1]-1)/2\n            if(length(shift)>1) shift = shift[sort(abs(shift), index.return=TRUE)$ix][1]\n            syllCutoffs[j] = syllCutoffs[j]+shift\n          }\n        }    \n        syllCutoffs      = data.frame(SongFile=wavfile, StroCounter = stroCutoffs$StroCounter[i], StroWindOffSamp=stroCutoffs$StartSampWoutPad[i], SyllCounter=1:I(length(syllCutoffs)-1),  SyllCounterRev=rev(1:I(length(syllCutoffs)-1)), SyllPosProp=1:I(length(syllCutoffs)-1)/length(syllCutoffs), SyllBegSamp=syllCutoffs[-length(syllCutoffs)], SyllEndSamp=syllCutoffs[-1])\n        syllCutoffs$SyllDurationSamp = syllCutoffs$SyllEndSamp-syllCutoffs$SyllBegSamp\n        syllCutoffs$SyllDurationSec  = syllCutoffs$SyllDurationSamp / ( f / (wl*(1-ovlp/100)))    \n        syllCutoffs$SyllValid = as.numeric(syllCutoffs$SyllDurationSec >= minSyllDur & syllCutoffs$SyllDurationSec <= maxSyllDur)\n        print(as.numeric(syllCutoffs$SyllDurationSec >= minSyllDur & syllCutoffs$SyllDurationSec <= maxSyllDur))\n      }\n              \n      # Plotting section\n      if(plot==TRUE) {\n        if(toFile==TRUE) jpeg(filename=paste0(syllpath,unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\"_Strophe\", stroCutoffs$StroCounter[i], \".jpg\"), width=bmpwidth, height=bmpheight)\n        par(mfrow=c(2,1))\n        if(!is.null(mar)) par(mar=mar)\n        if(is.null(xlimFullPlot)) xlimFullPlot = c(0,length(envFineTrunc))\n        if(is.null(xlimSyllPlot)) xlimSyllPlot = c(0,length(envFineTrunc))\n        #if(is.null(xlimPulsPlot)) xlimPulsPlot = c(0,length(envFineTrunc))\n        if(is.null(xlimSumPlot))  xlimSumPlot = c(0,length(envFineTrunc))\n        offsetRollMeanPlotSyll = 80\n        offsetRollMeanPlotPuls = 100\n      \n        # (1) Raw plot\n        plot  (envFineTrunc, type=\"l\", xaxt=\"n\", xlab=\"Time (sec)\", col=\"red\", xlim=xlimFullPlot)\n  #$      points(envMediTrunc, type=\"l\", col=\"blue\")\n        points(envCoarTrunc, type=\"l\", col=\"black\")\n        abline(h=stroAmpThresh)\n        axis(1, at=seq(0, mytime, by=0.5)*(f/(wl*(1-ovlp/100))), labels=seq(0, mytime, by=0.5))\n        if(!is.null(syllCutoffs)) abline(v=syllCutoffs$SyllBegSamp, col=\"blue\", lty=-1*syllCutoffs$SyllValid+2, lwd=lwdSyllSep)\n        if(!is.null(syllCutoffs)) abline(v=syllCutoffs$SyllEndSamp, col=\"blue\", lty=-1*syllCutoffs$SyllValid+2, lwd=lwdSyllSep)\n        \n        # (2) SyllDiff plot \n        plot (diffSyll, type=\"b\", xaxt=\"n\", col=\"blue\", xlim=xlimSyllPlot)\n        axis(1, at=seq(0, mytime, by=0.5)*(f/(wl*(1-ovlp/100))), labels=seq(0, mytime, by=0.5))\n        text(syllCutoffs$SyllBegSamp, max(diffSyll)*0.90, labels=syllCutoffs$SyllCounter, pos=4, cex=cex, col=c(\"grey90\", \"red\")[syllCutoffs$SyllValid+1])\n        points(rollmeansSyll+offsetRollMeanPlotSyll, type=\"b\", col=\"lightblue\")\n        abline(h=mean(rollmeansSyll)-meanReduceSyll+c(0,offsetRollMeanPlotSyll), lty=2, col=c(\"blue\", \"lightblue\"))\n        abline(h=mean(rollmeansSyll)+meanReduceSyll+c(0,offsetRollMeanPlotSyll), lty=2, col=c(\"blue\", \"lightblue\"))\n        if(!is.null(syllCutoffs)) abline(v=syllCutoffs$SyllBegSamp, col=\"blue\", lty=-1*syllCutoffs$SyllValid+2, lwd=lwdSyllSep)\n        if(!is.null(syllCutoffs)) abline(v=syllCutoffs$SyllEndSamp, col=\"blue\", lty=-1*syllCutoffs$SyllValid+2, lwd=lwdSyllSep)\n        par(mfrow=c(1,1))\n        if(toFile==TRUE) dev.off()\n      } \n      # Writing of results\n      if(writeRes) {\n        writefile = paste0(syllpath,unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\"_Strophe\", stroCutoffs$StroCounter[i], \"_Syllables.txt\")\n        if(file.exists(writefile) & overwriteRes==FALSE) print(\"Syllable identification: File not written, because it already exists! Set overwriteRes = TRUE if you are sure you want to replace the existing file!\")\n        else write.table(syllCutoffs, paste0(syllpath,unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\"_Strophe\", stroCutoffs$StroCounter[i], \"_Syllables.txt\"), sep=\"\\t\", quote=FALSE, row.names=FALSE)\n      }\n    }\n  }\n\n  # Return values\n\treturn(syllCutoffs = syllCutoffs)\t\n}",
    "created" : 1498579681713.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3800781066",
    "id" : "99CD6203",
    "lastKnownWriteTime" : 1506530149,
    "last_content_update" : 1506530149924,
    "path" : "~/A_Projects/Gomphocerus/SongAnalysis/GrassSongAnalysis/R/identifySyllables.R",
    "project_path" : "R/identifySyllables.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}