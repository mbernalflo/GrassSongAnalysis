{
    "collab_server" : "",
    "contents" : "#' Identify and plot sound evolopes and identify stroph cutoffs.\n#' \n#' Idendifies sound envelopes at three levels (on derived from the \n#' \\code{\\link{Wave}} object and two determined by smoothing. Plots the sound \n#' envelopes at the three levels in one plot, the difference between the \n#' coarsest and intermediate level in a second plot (for syllable \n#' identification) and the differeence between finest and intermidiate level \n#' in a third plot (in a third plot). Also applies automated strophe \n#' identification.\n#'\n#' @param envFine A sound envelope as a vector of numbers.\n#' @param wavfile Name of wavfile (required).\n#' @param stropath Path to folder in which jpg files should be plotted \n#'   (optional, working directory if missing). Directory will be created if \n#'   it does not exist.\n#' @param f Sampling rate (extracted from wavfile if NULL).\n#' @param plot Boolean, whether or not a plot should be in created.\n#' @param toFile Boolean, whether or not the plot should be in a .jpg file \n#'   (if TRUE) or in a plotting window (if FALSE).\n#' @param bmpwidth Width of the jpg image (in pixels).\n#' @param bmpheight Height of the jpg image (in pixels).\n#' @param rollmeanStroWW Vector of 2 (preferentially odd) numbers. The \n#'   rolling mean window width for determining the intermediate an coarse \n#'   envolopes from the finest resultion envolope determined by \\code{wl} and \n#'   \\code{ovlp}. The code works more accurate for odd numbers!\n#' @param wl Window length for the (finest) sound envelope given as the \n#'   number of sample points, At f=44100: 44 eq 1 ms (recommended), 441 eq 10 \n#'   ms, 4410 eq 100 ms.\n#' @param ovlp overlap between two successive windows (in percent, i.e., 0.\n#' @param stroAmpThresh Envelope threshold for identification of silence/sound \n#'   (i.e., Strophes). Recommended value depends on background noise level.\n#' @param StroThreshExceedWW The number of samples that is inspected for the \n#'   identification of strophe beginning and ends.\n#' @param StroThreshNeeded The number of samples within the window determined \n#'   by \\code{StroThreshExceedWW} that have to exceed the threshold determined \n#'   by \\code{stroAmpThresh} in order to qualify as a sound.\n#' @param MinStroDur A minimum duration for potential strophes to be analyzed \n#'   (in seconds).\n#' @param padding Boolean or number. If FALSE or 0, no padding will be applied. \n#'   If a number >0, padding at the beginning and end will be applied with \n#'   padding interpreted as the number of samples. If TRUE, padding at the \n#'   beginning and end will be applied with the number of samples determined \n#'   by the \\code{StroThreshExceedWW - StroThreshNeeded + 1} (recommended).\n#' @param stroCutoffs Optional \\code{data.frame} containing strophe \n#'   cutoffpoints (as returned by \\code{stroIdent}). If provided, strophe \n#'   cutoff identification will be skipped and strophe cutoffs will be plotted \n#'   as provided. Note that the padding has to be the same in the \n#'   \\code{stroCutoffs} as in \\code{padding}, since cutoffs will be plotted \n#'   with padding!).\n#' @param writeRes Boolean. Whether or not the strophe cutoffs should be \n#'   written to file.\n#' @param overwriteRes Boolean. This is just a safty catch. If  \\code{write = TRUE}\n#'   and \\code{overwriteRes = FALSE} the function will stop in order not to \n#'   overwrite previous manual edits.\n#' @param useResFile Boolean. A check is done, if a results file already exists and\n#'   the results of this file are used in \\code{useResFile = TRUE}\n#' @param xlim Vector of two numbers used to set x-limits in plot. Useful only to \n#'   zoom in when cutoffs are know.\n#' \n#' @details\n#' The algorithm in brief:\n#' \\itemize{\n#'  \\item Determine sound envelope with parameters \\code{wl} and \\code{ovlp} \n#'    using the function \\code{\\link{env}} from the \\code{link{seewave}} \n#'    package (using the default \\code{envt = \"hil\"}.\n#'  \\item Use a sliding window to determine the smoothed envelopes.\n#'  \\item Extend the sliding window sequences at the ends (by simply \n#'    replicating the first and last elements) so that the smoothed envelopes \n#'    have the same length as the original.\n#'  \\item Search for windows of size \\code{StroThreshExceedWW} in the \n#'    coaresets resolution that do/do no exceed the amplitude threshold \n#'    determined by \\code{stroAmpThresh}.\n#'  \\item Do some plotting and packaging of the results.\n#' }\n#' \n#' @return \n#' Returns the a list of 2 Elements:\n#' \\describe{\n#' \\item{stroCutoffs}{A \\code{data.frame} of detected strophe cutoff points. \n#'   The elements are:\n#'   \\describe{\n#'      \\item{StartSampWithPad}{The strophe start as the sample in \n#'        \\code{envFine} in the padded sequence.}\n#'      \\item{EndSampWithPad}{The strophe end as the sample in \\code{envFine} \n#'        in the padded sequence.}\n#'      \\item{StartSampWoutPad}{The strophe start as the sample in \n#'        \\code{envFine} in sequence without padding.}\n#'      \\item{EndSampWoutPad}{The strophe end as the sample in \\code{envFine} \n#'        in sequence without padding.}\n#'      \\item{StartSec}{The strophe start converted to seconds of the song \n#'        without padding.}\n#'      \\item{EndSec}{The strophe end converted to seconds of the song \n#'        without padding.}\n#'      \\item{DurSec}{The strophe duration in seconds.}\n#'      \\item{StroCounter}{A counter for strophes within the \\code{song}.}\n#'      \\item{StroValid}{Idicator if the strophe is valid (i.e., exceeds \n#'        \\code{MinStroDur}).}\n#'    }\n#'   }\n#' }\n#' \n#' @note \n#' Contains two work-arounds to avoid cutoffs that run in a sequence and uneven \n#' numbers of cutoffs (since usully start and end cutoffs are expected to occur \n#' in pairs).\n#' \n#' @author Holger Schielzeth  (holger.schielzeth@@uni-bielefeld.de)\n#'  \n#' @seealso \n#' \\code{\\link{loadSongfile}}, \\code{\\link{curateStrophes}}, \n#' \\code{\\link{identifySyllables}}, \\code{\\link{measureSyllables}}, \n#' \\code{\\link{identifyPulses}}, \\code{\\link{curateSyllables}}\n#' \n#' @examples   \n#' \n#' \\dontrun{\n#' \n#' mysound = filePreparation(\"myfile.wav\", \"C://mypath//\", highpassfilter=1001, select=c(0.5,2))\n#' plotEnvolopes(mysound, \"myfile.wav\", \"c://mystropath//\", padding = 300)\n#' }\n#' \n#' @export\n\nidentifyStrophes <- function(envFine, wavfile, stropath=\"\", f=44100, plot=TRUE, toFile=TRUE, bmpwidth=3200, bmpheight=600,\n                            # Note: Why has rollmeanStroWW two elements? \n                      rollmeanStroWW=c(11, 101), wl=44, ovlp=50, padding=TRUE,\n                      stroAmpThresh=15, StroThreshExceedWW=301, StroThreshNeeded=10, MinStroDur=0.5,\n                      stroCutoffs=NULL, writeRes=TRUE, overwriteRes=FALSE, useResFile=TRUE, xlim=NA) {\n  # Initial checks\n  if(any(rollmeanStroWW %% 2 == 0)) warning(\"Roll means window width should be odd numbers for higher accuracy. Found for rollmeanStroWW.\")\n  if(any(StroThreshExceedWW %% 2 == 0)) warning(\"Roll means window width should be odd numbers for higher accuracy. Found for StroThreshExceedWW.\")\n  if(is.logical(padding) && padding) padding = StroThreshExceedWW - StroThreshNeeded + 1\n  if(is.logical(padding) && padding ==FALSE || is.null(padding)) padding = 0\n  if(stropath!=\"\") {\n    if (!dir.exists(stropath)) {\n      dir.create(stropath)\n      print(paste0(\"Directory \", stropath, \" did not exist and was created.\"))\n    }\n  }\n    \n  readfile = paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\")\n  if(is.null(stroCutoffs) && useResFile && file.exists(readfile)) {\n    stroCutoffs = read.table(file=readfile, sep=\"\\t\", header=TRUE)\n    print(\"Existing file was read and used for cutoffs!\")\n    if(any(is.na(stroCutoffs))) {\n      stroCutoffs = recalcCutoffNAs(stroCutoffs, f=f, wl=wl, ovlp=ovlp, padding=padding, file=readfile)\n      print(\"Existing cutoffs file contained NAs that were recalcuated!\")\n    }\n  }\n  \n  if(is.null(stroCutoffs) || plot==TRUE) {\n    # Envelope identification\n    envStro = zoo::rollmean(envFine, rollmeanStroWW, align=\"center\")\n    envStro = c(rep(envStro[1], (rollmeanStroWW-1)/2), envStro, rep(envStro[length(envStro)], (rollmeanStroWW-1)/2))\n    mytime = length(envFine)/(f/(wl*(1-ovlp/100)))\n  \n    # Padding if requested\n    if(padding > 0) {\n      pad = rep(0,padding)\n      envFine = c(pad, envFine, pad)\n      envStro = c(pad, envStro, pad)    \n    }\n  }\n\n  if(is.null(stroCutoffs)) {\n    # Cutoff detection\n    envStroExcThresh = as.numeric(envStro>stroAmpThresh)\n    rollthreshExceed = zoo::rollmean(envStroExcThresh, StroThreshExceedWW, align=\"center\")\n    trend = rollthreshExceed[-1] - rollthreshExceed[-length(rollthreshExceed)]\n    trend = c(trend[1], trend)\n    stroCutoffs = as.numeric(rollthreshExceed > I(StroThreshNeeded-1)/StroThreshExceedWW & rollthreshExceed < I(StroThreshNeeded+1)/StroThreshExceedWW)\n    stroCutoffs = which(stroCutoffs==1)\n    stroCutoffs[stroCutoffs<padding] = padding\n    stroCutoffs[stroCutoffs>=length(envStroExcThresh)-padding] = length(stroCutoffs)-padding  \n    # A bit of a hack !!!!!\n    if(any(diff(stroCutoffs)==1)) {\n      repeat{\n        stroCutoffs = stroCutoffs[which(diff(stroCutoffs)==1)[1]*-1]\n        if(all(diff(stroCutoffs)>1)) break\n      }\n    }\n    ## Even more of a hack!!!!!\n    if(length(stroCutoffs)%%2 != 0) stroCutoffs = stroCutoffs[-length(stroCutoffs)]\n    \n    # Packaging of return object of cutoffs\n    stroCutoffs = data.frame(StroCounter=1:I(length(stroCutoffs)/2), StartSampWithPad=stroCutoffs[seq(1,length(stroCutoffs),by=2)], EndSampWithPad=stroCutoffs[seq(2,length(stroCutoffs),by=2)] ) \n    stroCutoffs$StartSampWoutPad = stroCutoffs$StartSampWithPad - padding\n    stroCutoffs$EndSampWoutPad   = stroCutoffs$EndSampWithPad - padding\n    stroCutoffs$StartSec         = stroCutoffs$StartSampWoutPad/(f/(wl*(1-ovlp/100)))\n    stroCutoffs$EndSec           = stroCutoffs$EndSampWoutPad/(f/(wl*(1-ovlp/100)))\n    stroCutoffs$DurSec           = stroCutoffs$EndSec - stroCutoffs$StartSec\n    stroCutoffs$StroValid        = as.numeric(stroCutoffs$DurSec > MinStroDur)\n  }\n  \n  # Setup of jpg file if necessary\n  if(plot) {\n    if(toFile) {\n      jpeg(filename=paste0(stropath,unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".jpg\"), width=bmpwidth, height=bmpheight)\n      on.exit(dev.off())\n    }\n    # Plotting section\n    # Raw plot\n    if(any(is.na(xlim))) plot(envFine, type=\"n\", xaxt=\"n\", xlab=\"Time (sec)\", col=\"red\")\n    if(any(!is.na(xlim))) plot(envFine, type=\"n\", xaxt=\"n\", xlab=\"Time (sec)\", col=\"red\", xlim=xlim)\n    text(stroCutoffs$StartSampWithPad, max(envFine)*0.90, labels=stroCutoffs$StroCounter, pos=4, cex=8, col=c(\"grey90\", \"red\")[stroCutoffs$StroValid+1])\n    points(envFine, type=\"l\", col=\"red\")\n    points(envStro, type=\"l\", col=\"black\")\n    abline(h=stroAmpThresh)\n    axis(1, at=seq(0, mytime, by=0.5)*(f/(wl*(1-ovlp/100))), labels=seq(0, mytime, by=0.5))\n    abline(v=stroCutoffs$StartSampWithPad, col=\"black\", lwd=c(1,8)[stroCutoffs$StroValid+1], lty=1) \n    abline(v=stroCutoffs$EndSampWithPad,   col=\"black\", lwd=c(1,8)[stroCutoffs$StroValid+1], lty=1) \n  }\n  \n  if(writeRes) {\n    writefile = paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\")\n    if(file.exists(writefile) & overwriteRes==FALSE) print(\"File not written, because it already exists! Set overwriteRes = TRUE if you are sure you want to replace the existing file!\")\n    else write.table(stroCutoffs, file=writefile, sep=\"\\t\", quote=FALSE, row.names=FALSE)\n  }\n  # Return values\n\treturn(stroCutoffs=stroCutoffs)\t\n}",
    "created" : 1497594989080.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "209655175",
    "id" : "A37F9004",
    "lastKnownWriteTime" : 1506529899,
    "last_content_update" : 1506529899608,
    "path" : "~/A_Projects/Gomphocerus/SongAnalysis/GrassSongAnalysis/R/identifyStrophes.R",
    "project_path" : "R/identifyStrophes.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}