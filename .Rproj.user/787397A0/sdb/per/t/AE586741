{
    "collab_server" : "",
    "contents" : "#' Function for curating automatically detected strophe cutoffs.\n#' \n#' The function takes existing cutoffs (typically read from a textfile), plots \n#' the amplitude envelpe and allows interactive setting of different cutoffs. \n#' NOTE: The function will only return the x-location (sample) of the new \n#' cutoff. The textfile will open, but it will have to be changed manually. \n#' Don't forget to save. The function will end with redrawing the .bmp file \n#' with the new cutoffs.\n#'\n#' @param envFine Sound envelope (typically at finest resolution, required).\n#' @param wavfile Name of wavfile (required).\n#' @param stropath Path of the strophe files (optional, working directory if \n#'   missing).\n#' @param f Sampling rate of .wav file. Requrired for conversion of sampling \n#'   units to seconds.\n#' @param wl Window width used when calculating the sound evolope. Requrired \n#'   for conversion of sampling units to seconds.\n#' @param ovlp Overlap of the windows (expressed as percentages, i.e. >=0 and \n#'   <100) used when calculating the sound evolope. Requrired for conversion \n#'   of sampling units to seconds.\n#' @param StroThreshExceedWW The number of samples that is inspected for the \n#'   identification of strophe beginning and ends.\n#' @param StroThreshNeeded The number of samples within the window determined \n#'   by \\code{StroThreshExceedWW} that have to exceed the threshold determined \n#'   by \\code{stroAmpThresh} in order to qualify as a sound.\n#' @param padding Boolean or number. If FALSE or 0, no padding will be applied. \n#'   If a number >0, padding at the beginning and end will be applied with \n#'   padding interpreted as the number of samples. If TRUE, padding at the \n#'   beginning and end will be applied with the number of samples determined by \n#'   the \\code{StroThreshExceedWW - StroThreshNeeded + 1} (recommended).\n#' @param rollmeanStroWW Vector of 2 (preferentially odd) numbers. The \n#'   rolling mean window width for determining the intermediate an coarse \n#'   envolopes from the finest resultion envolope determined by \\code{wl} and \n#'   \\code{ovlp}. The code works more accurate for odd numbers!\n#' @param MinStroDur A minimum duration for potential strophes to be analyzed \n#'   (in seconds).\n#' @param stroCutoffs (Optional) \\code{data.frame} with strophe cutoffs.\n#' @param confirmRevised Boolean. Whether or not the revised plot should be \n#'   shown on screen.\n#' @param replotToFile Boolean. Whether or not the plot should be written to file.\n#' @param bmpwidth Width of the jpg image (in pixels). Applies only to plot \n#'   written to file.\n#' @param bmpheight Height of the jpg image (in pixels).\n#' @param closeAllWindowsOnStart Boolean. Whether or not plotting windows should be\n#'   closed at the start.\n#' @param manualEdit Boolean. Whether or not manual edits should be applied. Otherwise\n#'   NAs in StroCutoffs are simply updated (and Stroph numbers reordered!).\n#' @param forceStartAtZero Boolean. Whether predictated starting times in the padding \n#'   area should be forced to start at point zero of the actual recording. \n#' @param ... Addional parameters handed over to \\code{\\link{identifyStrophes}} \n#'   for plotting.\n#' \n#' @return \n#' Returns a \\code{data.frame} of strophe cutoffs \n#' (\\code{\\link{identifyStrophes}} for details).\n#' \n#' @author Holger Schielzeth  (holger.schielzeth@@uni-bielefeld.de)\n#' \n#' @seealso \n#' \\code{\\link{loadSongfile}}, \\code{\\link{identifyStrophes}}, \n#' \\code{\\link{identifySyllables}}, \\code{\\link{measureSyllables}}, \n#' \\code{\\link{identifyPulses}}, \\code{\\link{curateSyllables}}\n#' \n#' @examples   \n#' \\dontrun{\n#' # No example yet.\n#' }\n#' \n#' @export\n\ncurateStrophes = function(envFine, wavfile, stropath, stroCutoffs=NULL, f=44100, wl=44, ovlp=50, padding=TRUE, \n                          rollmeanStroWW=c(11, 101), StroThreshExceedWW=0, StroThreshNeeded=0, stroAmpThresh=15, MinStroDur=0, \n                          confirmRevised = TRUE, replotToFile = TRUE, closeAllWindowsOnStart=TRUE, manualEdit = TRUE, \n                          bmpwidth=3200, bmpheight=600, forceStartAtZero = TRUE, ...) {\n  # Initial checks\n  if(is.logical(padding) && padding) padding = StroThreshExceedWW - StroThreshNeeded + 1\n  if(is.logical(padding) && padding ==FALSE || is.null(padding)) padding = 0\n  if(closeAllWindowsOnStart) replicate(length(dev.list()), dev.off())\n\n  updateTable = function(newCutoffs, stroCutoffs) {\n    newStartSampWithPad = newCutoffs[seq(1,length(newCutoffs), by=2)]\n    newEndSampWithPad   = newCutoffs[seq(2,length(newCutoffs), by=2)]\n    lenDiff = length(newStartSampWithPad)-nrow(stroCutoffs)\n    if(lenDiff>0) for(i in 1:lenDiff) stroCutoffs = rbind(stroCutoffs, rep(NA, ncol(stroCutoffs)))\n    if(lenDiff<0) stroCutoffs = stroCutoffs[1:length(newStartSampWithPad),]\n    stroCutoffs$StartSampWithPad = newStartSampWithPad\n    stroCutoffs$EndSampWithPad   = newEndSampWithPad\n    stroCutoffs$StroValid        = 1\n    stroCutoffs$StroCounter      = 1:nrow(stroCutoffs)\n    stroCutoffs[,4:8] = NA\n    stroCutoffs = recalcCutoffNAs(stroCutoffs, f=f, wl=wl, ovlp=ovlp, padding=padding, file=paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\"))\n    return(stroCutoffs)\n  }\n      \n  if(manualEdit) {\n    windows(30,7)\n    xlim=NA\n    stroSel=NA\n    repeat{\n      identifyStrophes(envFine, wavfile=wavfile, stropath=stropath, toFile=FALSE, \n           wl=wl, ovlp=ovlp, padding=padding, MinStroDur=MinStroDur,\n           StroThreshExceedWW=StroThreshExceedWW, StroThreshNeeded=StroThreshNeeded, stroAmpThresh=stroAmpThresh,\n           stroCutoffs=stroCutoffs, rollmeanStroWW=rollmeanStroWW, writeRes=FALSE, xlim=xlim, ...)\n      print(\"Locate new thresholds in plot ...\")\n      newCutoffs <- locator()$x\n      if(is.null(newCutoffs)) {\n        print(paste0(\"No changes to file \", wavfile, \".\"))\n      }\n      else {\n        if(length(newCutoffs) %% 2 == 1) {\n          print(paste0(\"An uneven number of  cuttoff points was selected! Please select and even number\"))\n          newCutoffs = newCutoffs[-length(newCutoffs)]\n        }\n        newCutoffs = round(newCutoffs,0)\n        print(newCutoffs)\n        if(!is.na(stroSel) && !is.null(newCutoffs)) {\n          newStartSampWithPad = newCutoffs[seq(1, length(newCutoffs), \n                                            by = 2)]\n          newEndSampWithPad = newCutoffs[seq(2, length(newCutoffs), \n                                             by = 2)]\n          stroCutoffs = stroCutoffs[-stroSel,]  \n          for (i in 1:length(newStartSampWithPad)) stroCutoffs = rbind(stroCutoffs, \n                                                                       c(NA, newStartSampWithPad[i], newEndSampWithPad[i], \n                                                                         rep(NA, ncol(stroCutoffs) - 4), 1))\n          stroCutoffs = stroCutoffs[order(stroCutoffs$StartSampWithPad), \n                                  ]\n          stroCutoffs$StroCounter = 1:nrow(stroCutoffs)\n          stroCutoffs[, 4:8] = NA\n          stroCutoffs = recalcCutoffNAs(stroCutoffs, f = f, wl = wl, \n                                      ovlp = ovlp, padding = padding, file = paste0(stropath, \n                                                                                    unlist(strsplit(wavfile, split = \".\", fixed = TRUE))[1], \n                                                                                    \".txt\"))\n          abline(v = newCutoffs, col = \"green\", lwd = 2)\n          newCutoffs=NULL\n        }\n        abline(v=newCutoffs, col=\"green\", lwd=2)\n      }\n      print(\"Choose: [D] Done, [C] Cancel & repeat, [S] save & change more, [E] edit file (cancel changes), [1-20] Zoom to strophe. Waiting for input ...\")\n      answer = readline()\n      xlim=NA\n      stroSel=NA\n      if(answer==\"S\" | answer==\"s\") {\n        if(!is.null(newCutoffs)) stroCutoffs = updateTable(newCutoffs, stroCutoffs)\n      }\n      if(answer==\"E\" | answer==\"e\") {\n        file.edit(paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\"))\n        print(\"Modify file and press RETURN when done...\")\n        scan()\n        stroCutoffs = read.table(paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\"), header=TRUE, sep=\"\\t\")\n      }\n      if(answer==\"1\" || answer==\"2\" || answer==\"3\" || answer==\"4\" || answer==\"5\" || answer==\"6\" || answer==\"7\" || answer==\"8\" || answer==\"9\" || answer==\"10\" || \n         answer==\"11\" || answer==\"12\" || answer==\"13\" || answer==\"14\" || answer==\"15\" || answer==\"16\" || answer==\"17\" || answer==\"18\" || answer==\"19\" || answer==\"20\") {\n        if(as.numeric(answer)>nrow(stroCutoffs)) print(\"Input ignored, because number larger than the number of strophes in file.\")\n        else xlim = c(stroCutoffs$StartSampWithPad[as.numeric(answer)]-300, stroCutoffs$EndSampWithPad[as.numeric(answer)]+300)\n        stroSel = as.numeric(answer)\n      }\n      if(answer==\"D\" | answer==\"d\" | answer==\"\") {\n        if(!is.null(newCutoffs)) stroCutoffs = updateTable(newCutoffs, stroCutoffs)\n        break\n      }\n    }\n    dev.off()\n  }\n  if(forceStartAtZero && any(stroCutoffs$StartSampWoutPad<0))  {\n    stroCutoffs$StartSampWithPad[stroCutoffs$StartSampWithPad<padding] = padding\n    stroCutoffs[, 4:8] = NA\n    stroCutoffs = recalcCutoffNAs(stroCutoffs, f = f, wl = wl, ovlp = ovlp, padding = padding)\n    \n  }\n  write.table(stroCutoffs, file=paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\"), sep=\"\\t\", quote=FALSE, row.names=FALSE)\n  #stroCutoffs = read.table(paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\"), header=TRUE, sep=\"\\t\")\n  #if(any(is.na(stroCutoffs))) \n  #  stroCutoffs = recalcCutoffNAs(stroCutoffs,f=f, wl=wl, ovlp=ovlp, padding=padding, file=paste0(stropath, unlist(strsplit(wavfile, split='.', fixed=TRUE))[1],\".txt\"))\n  if(replotToFile) {\n    identifyStrophes(envFine, wavfile=wavfile, stropath=stropath, toFile=TRUE, \n                   wl=wl, ovlp=ovlp, padding=padding, MinStroDur=MinStroDur,\n                   StroThreshExceedWW=StroThreshExceedWW, StroThreshNeeded=StroThreshNeeded, stroAmpThresh=stroAmpThresh,\n                   stroCutoffs=stroCutoffs, rollmeanStroWW=rollmeanStroWW, writeRes=FALSE, bmpwidth=bmpwidth, bmpheight=bmpheight, ...)\n  }\n  if(confirmRevised) {\n    windows(30,7)\n    identifyStrophes(envFine, wavfile=wavfile, stropath=stropath, toFile=FALSE, \n                   wl=wl, ovlp=ovlp, padding=padding, MinStroDur=MinStroDur,\n                   StroThreshExceedWW=StroThreshExceedWW, StroThreshNeeded=StroThreshNeeded, stroAmpThresh=stroAmpThresh,\n                   stroCutoffs=stroCutoffs, rollmeanStroWW=rollmeanStroWW, writeRes=FALSE, ...)\n    print(\"Check revised plot and press RETURN when done...\")\n    scan()\n    dev.off()\n  }\n  return(stroCutoffs=stroCutoffs)\n}\n",
    "created" : 1498752465525.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3515863265",
    "id" : "AE586741",
    "lastKnownWriteTime" : 1499081538,
    "last_content_update" : 1499081538220,
    "path" : "~/A_Projects/Gomphocerus/SongAnalysis/GrassSongAnalysis/R/curateStrophes.R",
    "project_path" : "R/curateStrophes.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}